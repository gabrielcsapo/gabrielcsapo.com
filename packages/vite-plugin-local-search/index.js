import fs from "fs";
import MarkdownIt from "markdown-it";
import fastGlob from "fast-glob";
import MiniSearch from "minisearch";

// TODO: this can't live here
import path from "path";
import remarkFrontmatter from "remark-frontmatter";
import { compileSync } from "@mdx-js/mdx";
import { visit } from "unist-util-visit";
import matter from "gray-matter";
import { VFile } from "vfile";
import readingTime from "reading-time";

function generateAlphabetHash(filePath) {
  const alphabet = "abcdefghijklmnopqrstuvwxyz";
  let hash = 0;

  for (let i = 0; i < filePath.length; i++) {
    const charCode = filePath.charCodeAt(i);
    hash = (hash << 5) - hash + charCode;
    hash |= 0; // Convert to 32bit integer
  }

  let hashString = "";
  do {
    const value = hash % alphabet.length;
    hashString += alphabet[Math.abs(value)];
    hash = (hash / alphabet.length) | 0;
  } while (hash);

  return hashString.toLocaleUpperCase();
}

function getFrontMatter(filePath) {
  const { name: fileName } = path.parse(filePath);
  if (filePath.indexOf(".md") === -1) {
    throw new Error("Trying to get the frontmatter of a non-md file");
  }

  const fileContent = fs.readFileSync(filePath, "utf8");
  const { data } = matter(fileContent);

  const file = new VFile(fileContent);
  file.history = [filePath];

  let autoGeneratedTitle = "";
  let autoGeneratedExcerpt = "";

  compileSync(file, {
    remarkPlugins: [
      remarkFrontmatter,
      function test() {
        let sentences = [];
        let currentSentenceCount = 0;
        let sentenceCount = 3;

        return (ast, vfile) => {
          visit(ast, "heading", (node) => {
            if (!autoGeneratedTitle) {
              const _autoGeneratedTitle = node.children
                .filter((child) => child.type === "text")
                // @ts-ignore
                .map((child) => child.value)
                .join(" ");

              autoGeneratedTitle = _autoGeneratedTitle;
            }
          });

          visit(ast, "text", (node) => {
            if (currentSentenceCount >= sentenceCount) {
              return;
            }

            const nodeSentences = node.value.match(/[^.!?]+[.!?]+/g) || [];
            const remainingSentences = sentenceCount - currentSentenceCount;
            if (nodeSentences.length <= remainingSentences) {
              sentences = sentences.concat(nodeSentences);
              currentSentenceCount += nodeSentences.length;
            } else {
              sentences = sentences.concat(
                nodeSentences.slice(0, remainingSentences)
              );
              currentSentenceCount = sentenceCount;
            }
          });

          autoGeneratedExcerpt = sentences.join(" ").trim();
        };
      },
    ],
  });

  const frontmatter = {
    ...data,
  };

  if (!frontmatter.date) {
    const datePart = fileName.substring(0, 10); // "2020-07-30"

    // Parse the string into a Date object
    frontmatter.date = new Date(datePart);
  }

  if (!frontmatter.slug) {
    frontmatter.slug = `/posts/${fileName}`;
  }

  if (!frontmatter.title) {
    frontmatter.title = autoGeneratedTitle;
  }

  if (!frontmatter.excerpt) {
    frontmatter.excerpt = autoGeneratedExcerpt;
  }

  if (frontmatter.image) {
    const absoluteImagePath = path.resolve(
      path.dirname(filePath),
      frontmatter.image
    );
    frontmatter.image = `/images/${
      generateAlphabetHash(absoluteImagePath) + path.extname(absoluteImagePath)
    }`;
    frontmatter.absoluteImagePath = absoluteImagePath;
  }

  if (frontmatter.layout) {
    frontmatter.layout = path.resolve(
      path.dirname(filePath),
      frontmatter.layout
    );
  } else {
    frontmatter.layout = path.resolve("./src/components/BlogLayout");
  }

  frontmatter.readingTime = readingTime(fileContent);
  frontmatter.locationOnDisk = filePath;

  return frontmatter;
}

const removeFrontMatter = (mdCode) => mdCode.replace(/^---(.|\W)*?---/, "");

const processMdFiles = (HTML_FOLDER, options) => {
  let allData = [];
  const postsPath = fastGlob.sync(`${HTML_FOLDER}/**/*.mdx`, {
    absolute: true,
  });

  for (const postPath of postsPath) {
    const postContent = fs.readFileSync(postPath, "utf8");

    allData.push({ content: removeFrontMatter(postContent), path: postPath });
  }

  return allData;
};

const rControl = /[\u0000-\u001f]/g;
const rSpecial = /[\s~`!@#$%^&*()\-_+=[\]{}|\\;:"'‚Äú‚Äù‚Äò‚Äô<>,.?/]+/g;
const rCombining = /[\u0300-\u036F]/g;

/**
 * Default slugification function
 */
export const slugify = (str) =>
  str
    .normalize("NFKD")
    // Remove accents
    .replace(rCombining, "")
    // Remove control characters
    .replace(rControl, "")
    // Replace special characters
    .replace(rSpecial, "-")
    // Remove continuos separators
    .replace(/-{2,}/g, "-")
    // Remove prefixing and trailing separators
    .replace(/^-+|-+$/g, "")
    // ensure it doesn't start with a number (#121)
    .replace(/^(\d)/, "_$1")
    // lowercase
    .toLowerCase();

const buildDoc = (mdDoc, id) => {
  let m, t;
  let a = (t = mdDoc.anchor);
  if ((m = /\{(.*?)\}/m.exec(mdDoc.anchor)) !== null) {
    a = m[0];
    t = mdDoc.anchor.replace(/\{(.*?)\}/m, "");
  }
  const frontmatter = getFrontMatter(mdDoc.path);
  let link = frontmatter.slug;

  a = slugify(a);
  if (a[0] == "#") a = a.replace("#", "");

  if (!id.includes(".0")) link += `#${slugify(a)}`;

  return {
    id,
    link,
    text: mdDoc.content,
    slug: a,
    sectionTitle: t,
    title: frontmatter.title,
  };
};

/**
 * Split an md content by anchors in several index docs
 * @param mdCode an md content
 * @param path path of md file
 * @returns array of index docs
 */
const parseMdContent = (mdCode, path) => {
  const result = mdCode.split(/(^|\s)#{2,}\s/gi);
  const cleaning = result.filter((i) => i != "" && i != "\n");
  const mdData = cleaning.map((i) => {
    let content = i.split("\n");
    let anchor = content?.shift() || "";
    return { anchor, content: content.join("\n"), path };
  });
  return mdData;
};

const buildDocs = async (HTML_FOLDER, options) => {
  const files = await processMdFiles(HTML_FOLDER, options);

  const docs = [];
  if (files !== undefined) {
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      let mdDocs = parseMdContent(file.content, file.path);

      for (let index = 0; index < mdDocs.length; index++) {
        const mdDoc = mdDocs[index];
        docs.push(buildDoc(mdDoc, i + "." + index));
      }
    }
  }
  return docs;
};

const md = new MarkdownIt();
let MAX_PREVIEW_CHARS = 62; // Number of characters to show for a given search result

export async function IndexSearch(HTML_FOLDER, options) {
  console.log("  üîé Indexing...");
  if (options.previewLength) MAX_PREVIEW_CHARS = options.previewLength;
  const docs = await buildDocs(HTML_FOLDER, options);

  const miniSearch = new MiniSearch({
    fields: ["title", "text"],
    storeFields: ["title", "sectionTitle", "link"],
  });
  miniSearch.addAll(docs);

  const js = `
  const searchIndex = ${JSON.stringify(miniSearch.toJSON())};

  export default searchIndex;
  `;

  console.log("  üîé Done.");

  return js;
}

const DEFAULT_OPTIONS = {
  previewLength: 62,
  buttonLabel: "Search",
  placeholder: "Search docs",
  allow: [],
  ignore: [],
};

export function searchPlugin(searchOptions) {
  const options = {
    ...DEFAULT_OPTIONS,
    ...searchOptions,
  };

  const virtualModuleId = "virtual:search";
  const resolvedVirtualModuleId = "\0" + virtualModuleId;

  return {
    name: "vite-plugin-search",
    enforce: "pre",

    async resolveId(id) {
      if (id === virtualModuleId) {
        return resolvedVirtualModuleId;
      }
    },
    async load(id) {
      if (id !== resolvedVirtualModuleId) return;

      const data = await IndexSearch(searchOptions.baseDir, options);

      return data;
    },
  };
}
