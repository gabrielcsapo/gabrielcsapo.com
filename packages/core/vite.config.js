import { defineConfig } from "vite";
import path from "path";
import mdx from "@mdx-js/rollup";
import react from "@vitejs/plugin-react-swc";
import inspect from "vite-plugin-inspect";
import url from "@rollup/plugin-url";
import remarkImageImport from "@gabrielcsapo/remark-image-import";
import { ViteImageOptimizer } from "vite-plugin-image-optimizer";
import { imagetools } from "vite-imagetools";
import remarkFrontmatter from "remark-frontmatter";
import remarkDirective from "remark-directive";
import remarkAdmonitions from "@gabrielcsapo/remark-admonitions";
import { rssPlugin } from "@gabrielcsapo/vite-plugin-rss";
import { searchPlugin } from "@gabrielcsapo/vite-plugin-local-search";
import fse from "fs-extra";

import fastGlob from "fast-glob";

import { compileSync } from "@mdx-js/mdx";
import { visit } from "unist-util-visit";
import matter from "gray-matter";
import fs from "fs";
import { VFile } from "vfile";
import readingTime from "reading-time";

const rssPostsData = [];

function getFrontMatter(filePath) {
  const { name: fileName } = path.parse(filePath);
  if (filePath.indexOf(".md") === -1) {
    throw new Error("Trying to get the frontmatter of a non-md file");
  }

  const fileContent = fs.readFileSync(filePath, "utf8");
  const { data } = matter(fileContent);

  const file = new VFile(fileContent);
  file.history = [filePath];

  let autoGeneratedTitle = "";
  let autoGeneratedExcerpt = "";

  compileSync(file, {
    remarkPlugins: [
      remarkFrontmatter,
      function test() {
        let sentences = [];
        let currentSentenceCount = 0;
        let sentenceCount = 3;

        return (ast, vfile) => {
          visit(ast, "heading", (node) => {
            if (!autoGeneratedTitle) {
              const _autoGeneratedTitle = node.children
                .filter((child) => child.type === "text")
                // @ts-ignore
                .map((child) => child.value)
                .join(" ");

              autoGeneratedTitle = _autoGeneratedTitle;
            }
          });

          visit(ast, "text", (node) => {
            if (currentSentenceCount >= sentenceCount) {
              return;
            }

            const nodeSentences = node.value.match(/[^.!?]+[.!?]+/g) || [];
            const remainingSentences = sentenceCount - currentSentenceCount;
            if (nodeSentences.length <= remainingSentences) {
              sentences = sentences.concat(nodeSentences);
              currentSentenceCount += nodeSentences.length;
            } else {
              sentences = sentences.concat(
                nodeSentences.slice(0, remainingSentences)
              );
              currentSentenceCount = sentenceCount;
            }
          });

          autoGeneratedExcerpt = sentences.join(" ").trim();
        };
      },
    ],
  });

  const frontmatter = {
    ...data,
  };

  if (!frontmatter.date) {
    const datePart = fileName.substring(0, 10); // "2020-07-30"

    // Parse the string into a Date object
    frontmatter.date = new Date(datePart);
  }

  if (!frontmatter.slug) {
    frontmatter.slug = `/posts/${fileName}`;
  }

  if (!frontmatter.title) {
    frontmatter.title = autoGeneratedTitle;
  }

  if (!frontmatter.excerpt) {
    frontmatter.excerpt = autoGeneratedExcerpt;
  }

  if (frontmatter.image) {
    const absoluteImagePath = path.resolve(
      path.dirname(filePath),
      frontmatter.image
    );
    frontmatter.image = `/images/${
      generateAlphabetHash(absoluteImagePath) + path.extname(absoluteImagePath)
    }`;
    frontmatter.absoluteImagePath = absoluteImagePath;
  }

  if (frontmatter.layout) {
    frontmatter.layout = path.resolve(
      path.dirname(filePath),
      frontmatter.layout
    );
  } else {
    frontmatter.layout = path.resolve("./src/components/BlogLayout");
  }

  frontmatter.readingTime = readingTime(fileContent);
  frontmatter.locationOnDisk = filePath;

  return frontmatter;
}

function findAllBlogPostsWithMeta() {
  const postsPath = fastGlob.sync("../../posts/**/*.mdx");
  for (const postPath of postsPath) {
    const data = getFrontMatter(postPath);

    rssPostsData.push({
      title: data.title,
      link: `https://www.gabrielcsapo.com${data.slug}`,
      pubDate: new Date(data.date),
    });
  }
}

function findAllBlogPosts() {
  const postsPath = fastGlob.sync("../../posts/**/*.mdx", {
    absolute: true,
  });
  return postsPath.map((postPath) => {
    return getFrontMatter(postPath);
  });
}

findAllBlogPostsWithMeta();

const virtualModuleId = "virtual:pages.jsx";
const resolvedVirtualModuleId = "\0" + virtualModuleId;

function generateAlphabetHash(filePath) {
  const alphabet = "abcdefghijklmnopqrstuvwxyz";
  let hash = 0;

  for (let i = 0; i < filePath.length; i++) {
    const charCode = filePath.charCodeAt(i);
    hash = (hash << 5) - hash + charCode;
    hash |= 0; // Convert to 32bit integer
  }

  let hashString = "";
  do {
    const value = hash % alphabet.length;
    hashString += alphabet[Math.abs(value)];
    hash = (hash / alphabet.length) | 0;
  } while (hash);

  return hashString.toLocaleUpperCase();
}

function getSlug(fileName, frontMatter) {
  let slug = fileName.replace(".jsx", "").replace(".mdx", "");

  // we want to replace all the index keywords as those are just /
  slug = slug.replace(/index/g, "");

  return frontMatter?.slug ?? slug;
}

async function getRoutesFromDir(dir, baseDir) {
  const entries = await fs.promises.readdir(dir, { withFileTypes: true });
  const dirPromises = entries.map(async (entry) => {
    if (entry.isDirectory()) {
      return getRoutesFromDir(path.join(dir, entry.name), baseDir);
    } else if (entry.name.endsWith(".jsx")) {
      const name = entry.name.replace(/.jsx$/, "");
      const routePath = getSlug(
        path.resolve(dir, entry.name).replace(baseDir + "/pages", "")
      );
      // we are going to find the closet layout or use the default layout
      const layout =
        entries.find((e) => {
          e.name === "Layout.jsx";
        }) ?? path.resolve(__dirname, "./src/Layout.jsx");

      return {
        path: routePath,
        component: path.resolve(dir, entry.name),
        layout,
      };
    }
  });
  const results = await Promise.all(dirPromises);
  return results.flat().filter((route) => route !== undefined);
}

function pages(options) {
  const baseDir = options.baseDir;
  const globals = options.globals;

  return {
    name: "vite-plugin-routes",
    resolveId(id) {
      if (id === virtualModuleId) {
        return resolvedVirtualModuleId;
      }
    },
    async load(id) {
      if (id === resolvedVirtualModuleId) {
        const hashes = {};
        const posts = findAllBlogPosts();
        const generatedPostRoutes = posts.map((post) => {
          return {
            path: post.slug,
            component: post.locationOnDisk,
            layout: post.layout,
            props: post,
          };
        });
        const routes = [
          ...(await getRoutesFromDir(
            path.resolve(baseDir, "src/pages/"),
            path.resolve(baseDir, "src/")
          )),
          ...generatedPostRoutes,
        ];

        const layoutImports = routes
          .map((route) => {
            hashes[route.layout] = generateAlphabetHash(route.layout);

            return `const ${generateAlphabetHash(
              route.layout
            )} = React.lazy(() => import('${route.layout}'));`;
          })
          .reduce(
            (unique, item) =>
              unique.includes(item) ? unique : [...unique, item],
            []
          )
          .join("\n");
        const imports = routes
          .map((route) => {
            hashes[route.component] = generateAlphabetHash(route.component);

            return `const ${generateAlphabetHash(
              route.component
            )} = React.lazy(() => import('${route.component}'));`;
          })
          .join("\n");

        return `
          import React from 'react';

          ${layoutImports}
          ${imports}

          const lookupMap = {
            ${Object.keys(hashes)
              .map((k) => `"${k}": ${hashes[k]},`)
              .join("\n")}
          };

          export const routes = ${JSON.stringify(routes)};
          export const posts = ${JSON.stringify(posts)};
          export const globals = ${JSON.stringify(globals || {})};

          export function getComponent(name) {
            return lookupMap[name];
          };
        `;
      }
    },
  };
}

const posts = findAllBlogPosts();

posts
  .filter((post) => {
    return post.absoluteImagePath;
  })
  .forEach((post) => {
    const potentialFilesLocation = path.resolve(
      path.dirname(post.locationOnDisk),
      "files"
    );
    if (fs.existsSync(potentialFilesLocation)) {
      fse.copySync(
        potentialFilesLocation,
        path.resolve(__dirname, "public", "files")
      );
    }
    fs.copyFileSync(post.absoluteImagePath, path.join("public", post.image));
  });

fse.copySync(
  path.resolve(__dirname, "..", "..", "posts", "files"),
  path.resolve(__dirname, "public", "files")
);

export default defineConfig({
  plugins: [
    mdx({
      remarkPlugins: [
        remarkDirective,
        remarkFrontmatter,
        remarkImageImport,
        remarkAdmonitions,
      ],
      providerImportSource: "@mdx-js/react",
    }),
    rssPlugin({
      mode: "define",
      items: rssPostsData,
      channel: {
        title: "Gabriel J. Csapo",
        link: "http://www.gabrielcsapo.com",
        description: "Blog for Gabriel J. Csapo",
      },
    }),
    pages({
      baseDir: __dirname,
      globals: {
        siteName: "Gabriel J. Csapo",
      },
    }),
    searchPlugin({
      baseDir: path.resolve(__dirname, "../../posts"),
    }),
    react(),
    url(),
    inspect(),
    imagetools(),
    ViteImageOptimizer(),
  ],
  resolve: {
    alias: {
      "@components": path.resolve(__dirname, "src", "components"),
      "@utils": path.resolve(__dirname, "src", "utils"),
    },
  },
  build: {
    outDir: path.resolve(__dirname, "dist"),
  },
});
